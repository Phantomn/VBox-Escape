# CVE-2018-{3055,3085}

*Author*: [@_niklasb](https://twitter.com/_niklasb)

The exploit in `exploit.py` uses CVE-2018-3055
/ [ZDI-18-684](https://www.zerodayinitiative.com/advisories/ZDI-18-684/) & CVE-2018-3085
/ [ZDI-18-685](https://www.zerodayinitiative.com/advisories/ZDI-18-685/) to obtain
an arbitrary absolute read/write primitive, as well as RIP control in the VirtualBox
host process, for versions up to 5.2.14 with 3D acceleration enabled.

It is written for a Linux host & guest.

See [my blog post](https://phoenhex.re/2018-07-27/better-slow-than-sorry) for details
about these bugs.


## Explanation

We make heavy use of `CRVBOXSVCBUFFER_t` objects on the heap to achieve
a repeatable arbitrary write primitive. This type has the following layout:

```cpp
typedef struct _CRVBOXSVCBUFFER_t {
    uint32_t uiId;
    uint32_t uiSize;
    void*    pData;
    _CRVBOXSVCBUFFER_t *pNext, *pPrev;
} CRVBOXSVCBUFFER_t;
```

We can allocate and write to such a buffer via the HGCM function
`SHCRGL_GUEST_FN_WRITE_BUFFER`.  Aside from heap spraying, the exploit uses two
buffers called `master` and `victim`. It corrupts `master->pData` such that it
points to `victim`.  Afterwards we can repeatably set `victim->pData` by
writing to `master`.

We leak the address of a `CRConnection` object, containing the
`pHostBuffer` pointer from which data is transferred to the guest, as well as
multiple function pointers.

An arbitrary read is obtained by overwriting the `pHostBuffer` field of a
connection and then using the `SHCRGL_GUEST_FN_READ` HGCM call. RIP control is
obtained by overwriting the `Free` member, which is a callback used to free
messages.


## Usage

Run against a vulnerable version of VirtualBox, ideally between 5.2.0 and 5.2.14,
with 3D acceleration enabled. Guest additions should be installed in the guest
(otherwise you need to install them, which requires root privileges). For example:

```bash
$ VBoxHeadless -s <vmname> &
$ sudo gdb -p $(pgrep -f vmname) -ex c
```

Then run the exploit inside the guest:

```bash
$ ./exploit.py
[*] Header for buffer # 13660 is at 0x00007f7568423fb0 (master)
[*] Header for buffer # 14660 is at 0x00007f756843f4c0 (victim)
[*] Leaked CRConnection @ 0x00007f7568622c90
[*] Writer payload @ 0x00007f7568640f70
[*] Leaked crVBoxHGCMFree @ 0x00007f760072f4d0
[*] Verifying read/write primitive by writing 0xdeadbeefdeadbeef to 0x00007f7568640f80
you want RIP control? [y/n] y
```

At this point the VM process will crash at RIP = 0xdeadbeef, with controlled
data pointed to by RDI. Instead we could set RIP = `system` and specify an
arbitrary command, or pivot into a ROP chain to execute arbitrary shellcode.
This requires some dynamic resolving of function addresses however, or
hardcoding offsets.


## `trigger-CVE-2018-3085.py`

This is a simpler PoC which only triggers CVE-2018-3085 to cause a Chromium
message to be fetched from `0xdeadbeef`.
